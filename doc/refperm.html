<html>
  <head>
	  <title>Permissions - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Permissions</div>
		</div>

    <div class="text">

	<p>Permissions enable and constrain how variables and references may be used.
	For example, they grant or deny the right to read a value, modify a value, make a copy of an reference,
	or share access to values across threads.</p>
	<p>Their primary purpose is to improve program safety by preventing race conditions,
	where multiple concurrent threads step on each other when trying to access the same value.
	Prudent use of permissions can also help make code easier to understand and improve execution performance.</p>
	
	<h2>Static permissions</h2>
	<p>Several permissions are built in to the language.
	These permissions are static, which means they are completely enforced when the program is compiled.
	They need no runtime enforcement support, making them more efficient than runtime permissions.</p>
	
	<h3>imm, mut and mmut</h3>
	<p>Three permissions form the root set of static permissions:
	<ul>
	<li><span class="pre">imm</span> (immutable)
	declares that a variable or reference's value will never change after it is initialized.
	Multiple threads may share access to immutable values.</li>
	<li><span class="pre">mut</span> (mutable) allows a variable or reference's
	value to be changed after initialization.
	Only one working variable or reference has access to that value at a time,
	however that single owner access may be transferred to other variables or threads.</li>
	<li><span class="pre">mmut</span> (multiple mutable)
	allows multiple references and/or variables to access or change a specific value.
	However, all references to such values are restricted to a single thread.
	Also, <span class="pre">mmut</span> restricts sum typed values from interior references.</li>
	</ul>
	
	<h4>mut and Lexical Ownership</h4>
	<p>The <span class="pre">mut</span> permission seems powerful on first glance.
	Not only does it allow both reads and writes, it allows the reference to move from thread-to-thread.
	However, the <span class="pre">mut</span> permission does have one significant limitation:
	there can only be one active reference to its value at a time.</p>
	<p>The language enforces this restriction:</p>
	<ul>
	<li><span class="pre">mut</span> references are never copied; they are always moved.
	The original variable that held the reference is no longer usable.
<pre>
mut var = 5
imm ref = &amp;mut var
imm ref2 = ref   // Moves the reference from ref to ref2
imm var2 = *ref  // Error: ref is no longer usable
</pre>
	</li>
	<li>Whenever a reference is borrowed from a <span class="pre">mut</span> reference,
	the original reference is unusable for the lifetime of the borrowed reference.
<pre>
mut pt = Point {x: 1, y: 2}
  imm ref = &amp;mut pt
  ref.x = 4
  pt.x = 5    // Error, pt is unusable while borrowed 'ref' exists
pt.x = 5      // Allowed, since borrowed 'ref' has expired
</pre>
	</li>
	</ul>
	<p>This restriction makes <span class="pre">mut</span> references unsuitable for
	many data structures that require the use of multiple references to the same object.</p>
	
	<h4>mut Coercion</h4>
	<p>One of the key advantages of the <span class="pre">mut</span> permission is that
	a reference with that permission may be safely converted into a reference of any other permission.
	Thus, it is possible to convert a <span class="pre">mut</span> reference into an
	<span class="pre">imm</span> or <span class="pre">mmut</span> reference,
	both allowing multiple references to the same object (but imposing other restrictions).</p>
	<p>This coercion flexibility of <span class="pre">mut</span>
	is the reason constructors typically return a new <span class="pre">mut</span> value.
	Freshly made, there exists only one reference to the brand new object.
	A subsequent permission coercion can transform this single reference (with zero runtime overhead)
	into a reference with a different permission:</p>
<pre>
imm ptimm &amp;imm Point = Point {x: 1, y: 2}
imm ptmmut &amp;mmut Point = Point {x: 1, y: 5}
</pre>

	<h3>const, mutx and id</h3>
	<p>The remaining static permissions are temporary permissions derived from the three root permissions.
	General-purpose functions specify them on their reference parameters,
	enabling them to flexibly handle references carrying many different permissions.
	These temporary permissions describe a function's intended use of the reference:</p>
	<ul>
	<li><span class="pre">const</span> (constant)
	declares that the reference will only be used to read its value, and will not attempt to modify it.
	A <span class="pre">const</span> parameter accepts nearly any other kind of reference, including
	<span class="pre">mut</span>, <span class="pre">mmut</span>, or <span class="pre">imm</span>.
	<p>Although similar, the difference between <span class="pre">const</span> and <span class="pre">imm</span>
	is important. 
	<span class="pre">imm</span> guarantees that no other mutable reference to the same object exists,
	making it safe to share between threads. <span class="pre">const</span> makes no such guarantee.
	Therefore, <span class="pre">const</span> references cannot be safely shared with another thread.</p>
	</li>
	<li><span class="pre">mutx</span> (exclusive mutable) 
	declares that the reference will be used to read or modify the value it refers to.
	However (similar to mut), it promises never to allow two usable copies of the reference to exist at the same time.
	A <span class="pre">mutx</span> parameter accepts a 
	<span class="pre">mut</span>, <span class="pre">mmut</span>, or <span class="pre">mutx</span> reference.
	<p>Although <span class="pre">mut</span> and <span class="pre">mutx</span> are similar,
	a <span class="pre">mut</span> reference may be moved to another thread;
	a <span class="pre">mutx</span> reference may not be.
	This is because <span class="pre">mut</span> promises no other reference to the object exists.
	<span class="pre">mutx</span> cannot make that promise.</p>
	</li>
	<li><span class="pre">id</span> (identifier)
	declares that this reference will never be used to read or modify its value.
	It may only be compared with another reference.
	It may be derived (coerced) from any reference.</li>
	</ul>

	<h3>Thread Communications</h3>
	<p>Among the static permissions, only <span class="pre">imm</span> references may be shared between threads.
	Additionally, a <span class="pre">mut</span> reference may be moved from one thread to another.
	All references to an object carrying any other permission are restricted to the same thread.</p>
	
	<h3>Struct member permissions</h3>
	<p>TBD</p>
	
	<h2>Runtime (Synchronization) Permissions</h2>
	<p>In addition to the static permissions, Cone also offers runtime permissions.
	Runtime permissions enable the use of shared references that are not limited by 
	the restrictions placed on <span class="pre">mmut</span> references.
	Using runtime permissions, it becomes possible to share object references across threads
	or to obtain interior references to shared references on sum or array types.</p>
	<p>The penalty for this added freedom is that reference use carries a small runtime performance hit.
	This is because runtime permissions wrap every use of the reference to access its contents
	with that runtime permission's synchronization mechanism
	that ensures that only one reference at a time can read or change its value.
	The other potential penalty is that use of runtime permissions 
	can sometimes suffer from deadlocks or runtime panics.</p>
	
	<h3>Runtime Permission Coercions</h3>
	<p>The only coercion allowed by runtime permissions is from a
	<span class="pre">mut</span> permission to any runtime permission.
	This is a one-way trip. If one reference to an object uses a runtime permission,
	all other references to that object must use the same runtime permission.</p>
	<p>This means that objects protected by runtime permissions cannot use functions
	that accept <span class="pre">const</span> or <span class="pre">mutx</span> references.
	They can only use functions whose reference parameters share the same permission.</p>
	<p>That said, any runtime permission reference may be coerced to an
	<span class="pre">id</span> reference.</p>
	
	<h3>Lock</h3>
	<p>The Lock permission enables multiple, mutable references to be shared and used across threads.
	It makes use of hardware intrinsics to ensure only one reference at a time can
	read or modify the contents of the reference.</p>
<pre>
imm point &amp;Lock Point = &amp;Gc Lock Point(x:2, y: 3)
thread.sendPoint(point)  // Now another thread has a copy of this reference
point.x += point.y  // Access to point safely protected by Lock twice
</pre>
	
	<h3>MutLock</h3>
	<p><span class="pre">mmut</span> references are restricted from obtaining 
	interior references to sum-typed or variable-sized array objects.
	This restriction is necessary to protect the structural integrity of these objects.
	Otherwise, it might be possible for one reference to alter the structure of the object
	while another reference holds an interior pointer now invalidated by the structural change.
	Unsafe things could happen if the interior pointer was then used.</p>
	<p>The <span class="pre">MutLock</span> permission lifts this restriction by
	allowing interior references to be obtained within an object that has multiple, shared references.
	So long as the interior reference exists, the runtime mechanism ensures that
	no other reference may access the object.
	If access is attempted, a panic results.</p>
<pre>
TBD
</pre>
	<p>Because the <span class="pre">MutLock</span> permission does not use hardware synchronization intrinsics,
	its runtime overhead is less than <span class="pre">Lock</span>.
	However, this means that all <span class="pre">MutLock</span> references for an object
	are restricted to the same thread.</p>
	
	<h3>Custom Permissions</h3>
	<p>It is possible to define additional runtime permissions ... TBD</p>
<pre>
perm NewLock
  ....
</pre>
	
	<p style="text-align: right; margin-top: 2em;">
		<a href="refalloc.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>