<html>
  <head>
	  <title>Packages and Modules - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Packages and Modules</div>
		</div>

    <div class="text">
	
	<p>Packages and modules help organize code distributed across many files, folders and/or servers:
	<ul>
	<li>A <b>package</b> is a collection of source files that are transformed by a build system
	into some desired target, such as a program or library.
	A package may contain one or more modules.</li>
	<li>A <b>module</b> is a namespace that gathers together a collection of
	named types, functions, global variables, constants and other modules.
	Each Cone source file is considered to be a module.</li>
	</ul>
	<p>For convenience, the names and structure for packages and modules deliberately mirrors
	how source files are named and organized into folders.</p>

	<h2>Module Namespace Structures</h2>
	<p>The filename for a program package's main source file is typically "main.cone".
	Similarly, the file for a library package's main source file is typically "lib.cone".
	In most cases, all types, functions, global variables, and constants in this file
	are considered part of the same module (namespace).</p>
	<p>There are several approaches for defining additional namespaces accessible by this module.</p>
	
	<h3>Explicit module blocks</h3>
	<p>One way is to define a distinct named module block within the source file's module:</p>
<pre>
mod frontend
  fn get() ...
  
fn main()
  frontend::get()
</pre>
	<p>In this example, frontend is a module containing several functions, including get.
	When we want to refer to get() outside that module, we must prefix the name using '::'
	together with the name of the module it belongs to.</p>
	
	<h3>Modules as separate files</h3>
	<p>More commonly, every module is defined in its own source file.
	In the above example, the code within frontend would be moved to a source file named frontend.cone.
	If this module is part of the same package, it is referenced by every module that needs it this way:
<pre>
mod frontend;

fn main()
  frontend::get()
</pre>

	<h3>Submodules organized by folders</h3>
	<p>If we want to add another layer of modules,
	such as allowing frontend to have its own modules (e.g., loader),
	it become necessary to organize these source files using subfolders.
	Instead of a source file named frontend.cone, a folder called frontend is created.
	Within that folder we place a file called mod.cone that contains the code that used to be in frontend.cone.
	All submodules of frontend, such as loader, each get their own named source file (e.g., loader.cone).
	If we move get() into the loader module, the main program would 
	need to refer to it as frontend::loader::get();</p>
	
	<h3>Modules defined by another package</h3>
	<p>To reference modules in other packages, use "package" rather than "mod". 
	The name of the package becomes the highest level module name.</p>
	<p>So, if we moved "frontend" to its own library package, the example would now be:</p>
<pre>
package frontend;

fn main()
  frontend::loader::get()
</pre>
	<p>The build system uses information in the package's configuration file
	to retrieve the code for the desired version of the referenced package from its home on the Internet.</p>
	<p>It is not necessary to specify a package statement for the standard library (std),
	as this is automatically performed.</p>
	
	<h2>Path names</h2>
	<p>A reference to a named entity in another module (namespace) is called a path name.
	Typically, path names are relative to the current module. This behavior can be overridden with a prefix:
	<ul>
	<li>A path name beginning with '::' begins with the current package's main (root) namespace.</li>
	<li>A path name may begin with super::, which refers to the module that holds the current module.</li>
	</ul>

	<h2>Private vs. public</h2>
	<p>The names within a module's namespace may be public or private:</p>
	<ul>
	<li><b>Public</b> names are visible to any other module</li>
	<li><b>Private</b> names are only visible to code within the same module</li>
	</ul>
	<p>Private names begin with an underscore. Public names do not.</p>
	
	<h2>Use importing for namespace mixing</h2>
	<p>Sometimes it can become tedious to repetitively use fully-qualified path names for frequently used names.
	The "use" command may be used to fold specified names into the current module's namespace.
	For example:</p>
<pre>
use frontend::loader::get

fn main()
  get() // 'get' is now part of main's namespace
</pre>
	<p>An alias may be given for an imported name to avoid potential conflicts:</p>
<pre>
use frontend::loader::get as load

fn main()
  load() // We must use the alias
</pre>
	<p>All names within a namespace may be imported using a glob (*):</p>
<pre>
use frontend::loader::*

fn main()
  get()
</pre>
	<p>The standard library's namespace is implicitly imported this way in every module:  "use ::std::*"</p>
	
	<p style="text-align: right; margin-top: 2em;">
		<a href="refconcur.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>