<html>
  <head>
	  <title>Packages and Modules - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Packages and Modules</div>
		</div>

    <div class="text">
	
	<p>Packages and modules are namespaces which organize code
	that is distributed across many files, folders and/or servers:
	<ul>
	<li>A <b>package</b> is a collection of source files that are transformed by a build system
	into a specific program or library.
	A package may contain one or more modules.</li>
	<li>A <b>module</b> is a namespace that gathers together a collection of
	named types, functions, global variables, constants and other modules.
	A module may encompass part of a source file, the whole source file,
	or span multiple source files. Modules are nestable.</li>
	</ul>
	<p>By convention, the names and structure for packages and modules typically maps closely to
	how source files are named and organized into folders.</p>

	<h2>Module Namespace Structures</h2>
	<p>The filename for a program package's main source file is typically "main.cone".
	Similarly, the file for a library package's main source file is typically "lib.cone".
	Typically, all types, functions, global variables, and constants in such a file
	are considered part of the same module (namespace).</p>
	<p>There are several approaches for defining additional namespaces accessible by this module.</p>
	
	<h3>Embedded modules</h3>
	<p>One way is to define a distinct named module block within the source file's module:</p>
<pre>
mod frontend
  fn get() ...
  
fn main()
  frontend::get()
</pre>
	<p>In this example, frontend is a module containing several functions, including get.
	When we want to refer to get() outside that module, we must prefix its name
	with the name of the module it belongs to, using <span class="pre">::</span> to separate these names.</p>
	
	<h3>Modules as separate files</h3>
	<p>More commonly, every module is defined in its own source file.
	This means that the frontend module code in the above example would be moved to a source file named frontend.cone.
	Any module in the same package that needs the names defined by frontend would specify where to get it:</p>
<pre>
mod frontend;

fn main()
  frontend::get()
</pre>

	<h3>Nested submodules and folders</h3>
	<p>If we want to add another layer of modules,
	such as allowing frontend to have its own modules (e.g., loader),
	it become necessary to organize these source files using subfolders.
	Instead of a source file named frontend.cone, a folder called frontend is created.
	Within that folder we place a file called mod.cone that contains the code that used to be in frontend.cone.
	All submodules of frontend, such as loader, each get their own named source file (e.g., loader.cone).
	If we move get() into the loader module, the main program would 
	need to refer to it as frontend::loader::get();</p>
	
	<h3>Modules that span multiple files</h3>
	<p>To incorporate another file's contents as part of the current namespace,
	use <span class="pre">include</span> instead of <span class="pre">mod</span>:
<pre>
include frontend;

fn main()
  get() // frontend:: is no longer necessary
</pre>

	<h3>Modules defined by another package</h3>
	<p>To reference modules in other packages,
	use <span class="pre">import</span> rather than <span class="pre">mod</span>.
	The name of the package becomes the highest level module name.</p>
	<p>So, if we moved "frontend" to its own library package, the example would now be:</p>
<pre>
import frontend;

fn main()
  frontend::loader::get()
</pre>
	<p>The build system uses information in the package's configuration file
	to retrieve the code for the desired version of the referenced package from its home on the Internet.</p>
	<p>It is not necessary to import the standard library (std), as this happens automatically for every module.</p>
	
	<h2>Path names</h2>
	<p>A reference to a named entity in another module (namespace) is called a path name.
	Typically, path names are relative to the current module. This behavior can be overridden with a prefix:
	<ul>
	<li>A path name beginning with '::' begins with the current package's main (root) namespace.</li>
	<li>A path name may begin with super::, which refers to the module that holds the current module.</li>
	</ul>

	<h2>Private vs. public</h2>
	<p>The names within a module's namespace may be public or private:</p>
	<ul>
	<li><b>Public</b> names are visible to any other module</li>
	<li><b>Private</b> names are only visible to code within the same module</li>
	</ul>
	<p>Private names begin with an underscore. Public names do not.</p>
	
	<h2>Mixing namespaces</h2>
	<p>It can become tedious to repetitively use fully-qualified path names for frequently used names.
	The "use" command folds another module's specified name(s) into the current module's namespace.
	For example:</p>
<pre>
use frontend::loader::get

fn main()
  get() // 'get' is now part of main's namespace
</pre>
	<p>An alias may be given for an imported name to avoid potential conflicts:</p>
<pre>
use frontend::loader::get as load

fn main()
  load() // We must use the alias
</pre>
	<p>All names within a namespace may be imported using a glob (*):</p>
<pre>
use frontend::loader::*

fn main()
  get()
</pre>
	<p>The standard library's namespace is implicitly imported this way in every module:  "use ::std::*"</p>
	
	<p style="text-align: right; margin-top: 2em;">
		<a href="refconcur.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>