<html>
  <head>
	  <title>Pointers - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Pointers</div>
		</div>

    <div class="text">

	<p>Pointers enable different parts of a program to access the contents of some object without
	actually moving the object's contents around. 
	In many cases, copying around a pointer is faster than copying the object.
	Furthermore, pointers make it possible to have many different references to the same object,
	all of them seeing the most current contents of that object.</p>
	
	<p>The <span class="pre">&</span> operator is used to obtain a pointer to a variable's contents.
	The <span class="pre">*</span> (dereferencing) operator is used to access the contents a pointer points to:</p>
<pre>
imm a = 3
imm ptr = &amp;a    // ptr holds a pointer to a's contents
imm val = *ptr  // val is now 3
</pre>
	<p>Despite this seeming simplicity, pointers are powerful, flexible and fragile.
	In addition to describing variations on pointer use, this chapter also introduces
	pointer use constraints designed to help ensure program safety.</p>

	<h2>Pointer Type Declarations</h2>
	<p>Pointers are value types.
	Mirroring the <span class="pre">&amp;</span> operator,
	a pointer declaration begins with <span class="pre">&amp;</span>,
	followed (optionally) by the pointer's allocator and permission,
	and then always ending with the value type of the object being pointed at.</p>
<pre>
// pointer's allocator is gc and permission is mmut. Object's value type is Point
imm ptr1 &amp;gc-mmut Point

imm ptr2 &amp;mut Point   // omitted allocator is 'borrowed reference'
imm ptr3 &amp;Point       // omitted permission is 'const'
</pre>
	<p>Due to type inference, explicit pointer declarations are often unnecessary on most variable declarations. 
	However, functions typically do require explicit declaration of pointers used as parameters or return values.
	For example:</p>
<pre>
// next takes a pointer and returns a number
fn next(x &amp;i32) i32
  *x + 1

fn caller()
  imm a = 3
  next(&amp;a)  // gets back 4
</pre>

	<h3>Pointer Permission</h3>
	<p>Every pointer is given a permission that governs what can be done with it, 
	such as whether the pointer may be copied (aliased) or used to read or modify the object it points to.
	The <span class="pre">const</span> permission is the default given to a pointer when none is specified.
	<span class="pre">const</span> grants a pointer the ability to view the contents of the object but not change it.</p>
	<p>If some other permission than <span class="pre">const</span> is desired when
	creating a new pointer using the <span class="pre">&amp;</span> operator,
	specify it just after the <span class="pre">&amp;</span>:</p>
<pre>
mut a = 3
imm ptr = &amp;mut a  // ptr holds a mutable pointer to a's contents
imm val = *ptr    // val is now 3
*ptr = 10         // a is now 10. val is still 3.
</pre>
	<p>Note that the permission given to the pointer may not exceed the permissions granted
	to the variable that holds the object.
	Also notice that in this example, the variable 'ptr' that holds the pointer is itself immutable
	(it can only ever point to 'a'). However, it holds a pointer able to change (mutate) 'a'.
	These are distinct permissions governing different aspects of 'ptr'.</p>
	
	<h3>Pointer Allocator</h3>
	<p>A pointer may declare the allocator used to create the object and the pointer to it.
	Each allocator watches over the pointers in its domain, protecting against invalid memory references
	and automatically freeing objects when they are no longer needed.</p>
	<p>The initial pointer to an object is created by the allocator when the object is created.
	Making a copy of an allocator-specific pointer is as easy as an assignment or an argument on a function call.
	However, a variable can only hold a pointer whose allocator matches the allocator declared by the variable.</p>
	
	<h3>Borrowed References</h3>
	<p>A pointer that does <b>not</b> specify an allocator is called a borrowed reference.
	Borrowed references are lifetime-constrained, which means that a borrowed reference may never
	outlive the object it points to. This constraint is enforced by ensuring the lexical scope of the
	borrowed reference is wholly encompassed by the lexical scope of the pointer or object it borrowed from.</p>
	<p>There are two ways to create a borrowed reference:</p>
	<ul>
	<li>Use the <span class="pre">&amp;</span> operator to create a borrowed reference
	to a global, local or parameter variable.</li>
	<li>Copy an existing pointer into a variable or function parameter declared as a borrowed reference.
<pre>
// next takes an allocator-less borrowed reference
fn next(x &amp;mmut i32) i32
  *x += 1

fn caller()
  // Use GC allocator to allocate a new number
  imm nbrptr = &amp;gc-mmut i32(5)
  // Pass pointer to next (coerced to borrowed pointer)
  next(nbrptr)
</pre>
	</li>
	</ul>
	
	<h2>Pointers and Functions</h2>
	<p>A pointer may be created to any function using the <span class="pre">&</span> operator.
	Later, that pointer may be used to call the function it points to.</p>
<pre>
fn incr(x i32) i32
  x + 1

fn caller()
  imm fnptr = &amp;incr
  *fnptr(4)            // returns 5
</pre>
	<p>Using a similar technique, it is also possible to make use of anonymous functions:</p>
<pre>
fn caller()
  imm fnptr = &amp;fn incr(nbr i32) i32 {nbr+1}
  *fnptr(4)            // returns 5
</pre>
	<p>Note that pointers to functions are lifetime-constrained borrowed references.</p>

	<h2>Automatic Pointer Dereferencing</h2>
	<p>It is not necessary to use the <span class="pre">*</span> pointer dereference operator
	when applying a method to (or calling) an object pointed at by a pointer.
	It will be inferred automatically:</p>
<pre>
mut a = -4
imm ptr = &amp;mut a
imm y = ptr.abs    // y is 4. Equivalent to: (*ptr).abs
</pre>
	
	<h2>Pointers and Structs</h2>
	<p>Pointers and Structs can intersect in interesting ways.</p>
	<h3>Interior Pointer Within a Struct</h3>
	<p>The <span class="pre">&amp;</span> may be used to obtain a borrowed reference to a
	specific member of a struct.
<pre>
struct Point
  x f32
  y f32
  
imm point = Point(3., 2.)
imm ptr = &amp;point.y         // ptr is a borrowed reference
imm y3 = *ptr              // y3 will be 2.0
</pre>

	<h3>Pointers as members</h3>
	<p>A struct (or array or sum type) may include one or more pointers as members.
	A struct that holds pointers is not implicitly copyable.
	To become copyable, it must implement the 'clone' method.
	Otherwise, attempts to copy it will in fact move it (if allowed).</p>
	<p>Any type of pointer may be held by a struct, assuming the member type declarations match the pointers assigned.
	However, if a struct holds a borrowed reference, then it (like its borrowed reference)
	is lifetime-constrained to survive no longer than any of the borrowed references it holds.</p>

	<h3>Interface/Trait Fat Pointers</h3>
	<p>If a struct pointer is coerced through an interface or trait, a "fat" pointer is automatically created.
	The pointer is twice the size of a regular pointer, as it holds not only a pointer to the object
	but also a pointer to the "vtable" that maps the interface or trait's members/methods
	to their concrete position in the object's struct.</p>
	
	<h2>Pointers and Arrays</h2>
	<p>As with structs above, the <span class="pre">&amp;</span> operator
	may be used to obtain a pointer to a specific element of an array according to its valid index:</p>
<pre>
mut rolls = [3,5,2]
imm ptr = &amp;rolls[1]
imm roll = *ptr        // roll = 5
</pre>
	<p>To ensure that array pointers can be constrained to always stay within the boundaries
	of an array, pointer arithmetic can only be performed within a <span class="pre">trust</span> block.
	However, arrays offer built-in mechanisms like iterators and slices
	that make it possible to safely focus attention on a specific but changeable
	set of array elements.</p>

	<h2>Pointers and Sum Types</h2>
	<p>The <span class="pre">&amp;</span> operator may not be used to safely point 
	to an interior value within a sum type, due to the potential for structural changes to the sum typed
	object that invalidate the value being pointed at.
	The sum type's pattern matching facilities must be used to get such a borrowed reference,
	as the lifetime constraints on the match block and the object's permissions avoid
	the possibility of pointer misfires due to structural changes.</p>
	
	<h2>Lifetime Annotations</h2>
	<p>TBD. Only apply to borrowed references. Two scenarios.</p>
	
	<p style="text-align: right; margin-top: 2em;">
		<a href="refperm.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>